<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
    <uses-permission android:name="android.permission.ACCESS_BACKGROUND_LOCATION" />
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_LOCATION" />
    <uses-permission android:name="android.permission.ACCESS_NOTIFICATION_POLICY" />
    <uses-permission android:name="android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS" />
    <uses-permission android:name="android.permission.WAKE_LOCK" />
    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
    <uses-permission android:name="android.permission.SCHEDULE_EXACT_ALARM" />
    <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" />
    <!-- SFPE: Required for step counter sensor on Android 10+ -->
    <uses-permission android:name="android.permission.ACTIVITY_RECOGNITION" />
    <!-- SFPE: Required for high-frequency sensor reads (< 200ms interval) on Android 12+ -->
    <uses-permission android:name="android.permission.HIGH_SAMPLING_RATE_SENSORS" />
    <!--
        REMOVED: android.permission.ACTION_MANAGE_OVERLAY_PERMISSION
        This is NOT a permission — it is an Intent action string.
        Declaring it here does absolutely nothing. SYSTEM_ALERT_WINDOW
        (above) is the actual permission for overlay access.
    -->

    <application
      android:name=".MainApplication"
      android:label="@string/app_name"
      android:icon="@mipmap/ic_launcher"
      android:roundIcon="@mipmap/ic_launcher_round"
      android:allowBackup="false"
      android:theme="@style/AppTheme"
      android:usesCleartextTraffic="${usesCleartextTraffic}"
      android:enableOnBackInvokedCallback="false"
      android:supportsRtl="true">

      <!-- Google Maps API Key -->
      <meta-data
        android:name="com.google.android.geo.API_KEY"
        android:value="${googleMapsApiKey}" />

      <activity
        android:name=".MainActivity"
        android:label="@string/app_name"
        android:screenOrientation="portrait"
        android:configChanges="keyboard|keyboardHidden|orientation|screenLayout|screenSize|smallestScreenSize|uiMode"
        android:launchMode="singleTask"
        android:windowSoftInputMode="adjustResize"
        android:exported="true">
        <intent-filter>
            <action android:name="android.intent.action.MAIN" />
            <category android:name="android.intent.category.LAUNCHER" />
        </intent-filter>
      </activity>

      <!-- Notifee Foreground Service — keeps GPS running when app is in background -->
      <service
        android:name="app.notifee.core.ForegroundService"
        android:foregroundServiceType="location"
        android:exported="false"
        android:stopWithTask="false"
        android:enabled="true" />

      <!--
        FIX #1: Added foregroundServiceType="location" to HeadlessJsTaskService.

        On Android 14+, any service that accesses location — even indirectly through
        a headless task — MUST declare its foreground service type. Without this,
        Android 14 kills the geofence headless tasks (onGeofenceTransition,
        BootRescheduleTask) the moment they try to read GPS data, with a silent
        ForegroundServiceStartNotAllowedException. This is why geofence entry/exit
        events were firing but location was never obtained in headless context.
      -->
      <service
        android:name="com.facebook.react.HeadlessJsTaskService"
        android:foregroundServiceType="location"
        android:enabled="true"
        android:exported="false" />

      <!-- Boot Reschedule Service -->
      <service
        android:name=".BootRescheduleService"
        android:enabled="true"
        android:exported="false"
        android:foregroundServiceType="location" />

      <!-- Notifee Alarm Receiver -->
      <receiver
        android:name="app.notifee.core.AlarmReceiver"
        android:enabled="true"
        android:exported="false" />

      <!--
        FIX #2: Removed android:permission="android.permission.RECEIVE_BOOT_COMPLETED"
        from this receiver.

        The android:permission attribute on a <receiver> means: "only callers who
        HOLD this permission may send broadcasts to this receiver." It does NOT mean
        "this receiver requires this permission to run." 

        Effect of the old declaration: you were accidentally restricting who could
        trigger your boot receiver to only callers that hold RECEIVE_BOOT_COMPLETED.
        While the Android system itself holds all permissions and still delivers
        BOOT_COMPLETED, many OEM boot managers (Samsung, Xiaomi, MIUI) and 
        third-party recovery tools send their own quick-boot variants from processes
        that do NOT hold RECEIVE_BOOT_COMPLETED. This silently blocked your boot
        receiver from firing on those devices after a soft reboot.

        The uses-permission at the top of the manifest is all you need to declare
        that your app wants to receive boot broadcasts.

        FIX #3: Added android:directBootAware="true".

        When a device restarts, Android fires BOOT_COMPLETED in two phases:
          Phase 1 (Direct Boot): Fires immediately after kernel boots, BEFORE the
                                 user unlocks the screen. Only direct-boot-aware
                                 components receive it.
          Phase 2 (Full Boot):   Fires after the user unlocks (credential storage
                                 available). This is the standard BOOT_COMPLETED.

        Without directBootAware="true", your BootReceiver only receives Phase 2.
        On devices with aggressive Doze (Pixel, Samsung with lockscreen delay), 
        the window between Phase 1 and Phase 2 can be many minutes. During that
        window all your alarms are gone and nothing reschedules them.

        Note: Your BootRescheduleTask accesses Realm (credential-encrypted storage),
        so the task itself must handle the case where Realm isn't yet available
        (it already does via the try/catch in getRealm()). The receiver simply
        starts the reschedule process — Realm will open fine once Phase 2 is reached.
      -->
      <receiver
        android:name=".BootReceiver"
        android:enabled="true"
        android:exported="true"
        android:directBootAware="true">
        <intent-filter>
          <action android:name="android.intent.action.BOOT_COMPLETED" />
          <action android:name="android.intent.action.QUICKBOOT_POWERON" />
          <action android:name="com.htc.intent.action.QUICKBOOT_POWERON" />
          <!--
            FIX #3 (cont): Also listen for ACTION_LOCKED_BOOT_COMPLETED.
            This is the explicit Direct Boot broadcast. Registering for it
            ensures your receiver fires in Phase 1 even if the device OEM
            delays the standard BOOT_COMPLETED until after unlock.
          -->
          <action android:name="android.intent.action.LOCKED_BOOT_COMPLETED" />
        </intent-filter>
      </receiver>

    <!-- Persistent Alarm Receiver -->
    <receiver
      android:name=".PersistentAlarmReceiver"
      android:enabled="true"
      android:exported="false">
      <intent-filter>
        <action android:name="com.qybrix.silentzone.ALARM_TRIGGERED" />
      </intent-filter>
    </receiver>

    <!-- Headless JS Task Service for Alarms -->
    <service
      android:name=".AlarmHandlerService"
      android:enabled="true"
      android:exported="false"
      android:foregroundServiceType="location" />

    <!-- WorkManager initialization provider -->
    <provider
        android:name="androidx.startup.InitializationProvider"
        android:authorities="${applicationId}.androidx-startup"
        android:exported="false"
        tools:node="merge">
        <meta-data
          android:name="androidx.work.WorkManagerInitializer"
          android:value="androidx.startup"
          tools:node="remove" />
    </provider>

    </application>
</manifest>
